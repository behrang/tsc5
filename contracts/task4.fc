#include "imports/stdlib.fc";

int tlen(tuple) asm "TLEN";
forall X -> tuple setAt(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";
(tuple, ()) enqueue(tuple, [int, int, int, int, tuple]) asm "TPUSH";
(tuple, [int, int, int, int, tuple]) dequeue(tuple) asm
    """
        // t
        DUP // t t
        TLEN // t n
        DUP // t n n
        1 SETGLOB // t n
        UNTUPLEVAR // x_1 ... x_n
        1 GETGLOB // x_1 ... x_n n
        DEC // x_1 ... x_n (n-1)
        TUPLEVAR // x_1 t
        SWAP // t x_1
    """;

int encode(int row, int col) inline {
    ;; max length in advanced version is 31, so 5 bits is enough
    return (row << 5) + col;
}

(int, int) decode(int p) inline {
    int col = p & 0x1f;
    int row = p >> 5;
    return (row, col);
}

int is_solved?(int c, int e) inline {
    ( int cr, int cc ) = decode(c);
    ( int er, int ec ) = decode(e);

    ;; 4 3 5
    ;; 1 c 2
    ;; 7 6 8

    if cr == er {
        if cc - 1 == ec { ;; L
            return true;
        }
        if cc + 1 == ec { ;; R
            return true;
        }
    }

    if cr - 1 == er {
        if cc == ec { ;; T
            return true;
        }
        if cc - 1 == ec { ;; TL
            return true;
        }
        if cc + 1 == ec { ;; TR
            return true;
        }
    }

    if cr + 1 == er {
        if cc == ec { ;; B
            return true;
        }
        if cc - 1 == ec { ;; BL
            return true;
        }
        if cc + 1 == ec { ;; BR
            return true;
        }
    }

    return false;
}

(cell, tuple, tuple, tuple) append_item(cell visited, tuple queue, tuple squeue, tuple xstack,
        int tr, int tc, int breaks, int prob, int dist, tuple maze) inline {
    int t = encode(tr, tc);
    ( _, int v? ) = visited.udict_get?(10, t);
    ifnot v? {
        visited~udict_set_builder(10, t, begin_cell());
        int item = maze.at(tr).at(tc);
        tuple new_maze = maze.setAt(tr, maze.at(tr).setAt(tc, "!"u));
        if item == "."u {
            queue~enqueue([t, breaks, prob, dist + 1, new_maze]);
        } elseif item == "?"u {
            squeue~enqueue([t, breaks, prob + 1, dist + 1, new_maze]);
        } elseif item == "X"u {
            xstack = cons([t, breaks + 1, prob, dist + 1, new_maze], xstack);
        }
    }
    return ( visited, queue, squeue, xstack );
}

(int, int, int, tuple) choose_best(int b, int p, int d, tuple m, int tb, int tp, int td, tuple tm) inline {
    if tm.null?() {
        return ( b, p, d, m );
    }
    if d == 0 {
        return ( tb, tp, td, tm );
    }
    if tb < b {
        return ( tb, tp, td, tm );
    }
    if tb > b {
        return ( b, p, d, m );
    }
    if tp < p {
        return ( tb, tp, td, tm );
    }
    if tp > p {
        return ( b, p, d, m );
    }
    if td < d {
        return ( tb, tp, td, tm );
    }
    return ( b, p, d, m );
}

(int, int, int, tuple) do_solve(cell visited, int start, int end, int n, int m, tuple maze) {
    tuple queue = empty_tuple();
    tuple squeue = empty_tuple();
    tuple xstack = null();
    queue~tpush([start, 0, 0, 0, maze]);
    visited~udict_set_builder(10, start, begin_cell());

    int done? = false;
    do {
        if queue.tlen() {
            [int c, int breaks, int prob, int dist, maze] = queue~dequeue();
            if is_solved?(c, end) {
                return ( breaks, prob, dist + 1, maze);
            }

            (int cr, int cc) = decode(c);

            int tr = cr - 1;
            int tc = cc - 1;
            if (tr >= 0) & (tc >= 0) {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; TL
            }

            tc = cc + 1;
            if (tr >= 0) & (tc < m) {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; TR
            }

            tr = cr + 1;
            if (tr < n) & (tc < m) {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; BR
            }

            tc = cc - 1;
            if (tr < n) & (tc >= 0) {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; BL
            }

            tc = cc;
            if tr < n {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; B
            }

            tr = cr - 1;
            if tr >= 0 {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; T
            }

            tr = cr;
            tc = cc - 1;
            if tc >= 0 {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; L
            }

            tc = cc + 1;
            if tc < m {
                ( visited, queue, squeue, xstack ) = append_item(visited, queue, squeue, xstack, tr, tc, breaks, prob, dist, maze); ;; R
            }

        } elseif squeue.tlen() {
            queue~enqueue(squeue~dequeue());
        } else {
            done? = true;
        }
    } until done?;

    int b = 0;
    int p = 0;
    int d = 0;
    tuple z = null();

    while ~ xstack.null?() {
        [int c, int breaks, int prob, int dist, maze] = xstack~list_next();
        ( int x, int y ) = decode(c);
        ( int tb, int tp, int td, tuple tm ) = do_solve(visited, c, end, n, m, maze);
        ( b, p, d, z ) = choose_best(b, p, d, z, breaks + tb, prob + tp, dist + td, tm);
    }
    return ( b, p, d, z );
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;; find start (s) and end (e) positions
    int start = null();
    int end = null();
    int i = 0;
    while i < n {
        tuple row = maze.at(i);
        int j = 0;
        while j < m {
            int item = row.at(j);
            if item == "S"u {
                start = encode(i, j);
            }
            if item == "E"u {
                end = encode(i, j);
            }
            ;; todo: break if both are found
            j += 1;
        }
        i += 1;
    }
    return do_solve(new_dict(), start, end, n, m, maze);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}
