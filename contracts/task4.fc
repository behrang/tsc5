#include "imports/stdlib.fc";

global tuple visited;
global tuple queue;
global tuple squeue;
global tuple xqueue;
global int er;
global int ec;
global int result_breaks;
global int result_prob;
global int result_dist;
global tuple result_maze;

int tlen(tuple) asm "TLEN";

forall X -> tuple setAt(tuple t, int k, X x) asm(t x k) "SETINDEXVAR";

(tuple, ()) enqueue(tuple, [int, int, int, int, int, tuple]) asm
    """
        SWAP // e pq
        DUP // e pq pq
        TLEN // e pq n
        IFNOT:<{
            NIL // e pq cq
        }>ELSE<{
            TPOP // e pq cq
            DUP // e pq cq cq
            TLEN // e pq cq n
            255 PUSHINT // e pq cq n x=255
            EQUAL // e pq cq f
            IF:<{
                TPUSH // e pq
                NIL // e pq cq
            }>
        }>
        ROT // pq cq e
        TPUSH // pq cq
        TPUSH // pq
    """;
(tuple, [int, int, int, int, int, tuple]) dequeue(tuple) asm
    """
        DUP // pq pq
        FIRST // pq cq
        DUP // pq cq cq
        TLEN // pq cq n
        EXPLODEVAR // pq e_1 ... e_n n
        DEC // pq e_1 ... e_n n-1
        DUP // pq e_1 ... e_n n-1 n-1
        IF:<{
            TUPLEVAR // pq e_1 cq
            SWAP // pq cq e_1
            -ROT // e_1 pq cq
            SETFIRST // e_1 pq
            SWAP // pq e_1
        }>ELSE<{
            DROP // pq e_1
            SWAP // e_1 pq
            TPOP // e_1 pq cq
            DROP // e_1 pq
            SWAP // pq e_1
        }>
    """;

int is_solved?(int sr, int sc) inline {
    if sc < ec - 1 {
        return false;
    } elseif sc > ec + 1 {
        return false;
    } elseif sr < er - 1 {
        return false;
    } elseif sr > er + 1 {
        return false;
    } else {
        return true;
    }
}

() choose_best(int tb, int tp, int td, tuple tm) impure inline {
    ifnot td {
    } elseifnot result_dist {
        result_breaks = tb;
        result_prob = tp;
        result_dist = td;
        result_maze = tm;
    } elseif tb < result_breaks {
        result_breaks = tb;
        result_prob = tp;
        result_dist = td;
        result_maze = tm;
    } elseif tb > result_breaks {
    } elseif tp < result_prob {
        result_breaks = tb;
        result_prob = tp;
        result_dist = td;
        result_maze = tm;
    } elseif tp > result_prob {
    } elseif td < result_dist {
        result_breaks = tb;
        result_prob = tp;
        result_dist = td;
        result_maze = tm;
    }
}

() init_visited(int n, int m) impure inline {
    tuple row = empty_tuple();
    repeat m {
        row~tpush(0xffffffffffff);
    }
    visited = empty_tuple();
    repeat n {
        visited~tpush(row);
    }
}

int append?(int pr, int pc, int breaks, int prob, int dist) impure inline {
    int new_v = dist + (prob << 16) + (breaks << 32);
    int v = visited.at(pr).at(pc);
    if new_v < v {
        visited = visited.setAt(pr, visited.at(pr).setAt(pc, new_v));
        return true;
    }
    return false;
}

() add_to_queue(int sr, int sc, int breaks, int prob, int dist, tuple maze) impure inline {
    int item = maze.at(sr).at(sc);
    if item == "?"u {
        prob += 1;
    } elseif item == "X"u {
        breaks += 1;
    }
    if append?(sr, sc, breaks, prob, dist) {
        tuple new_maze = maze.setAt(sr, maze.at(sr).setAt(sc, "!"u));
        if item == "."u {
            queue~enqueue([sr, sc, breaks, prob, dist, new_maze]);
        } elseif item == "?"u {
            squeue~enqueue([sr, sc, breaks, prob, dist, new_maze]);
        } else {
            xqueue~enqueue([sr, sc, breaks, prob, dist, new_maze]);
        }
    }
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    set_gas_limit(100000000);
    ;; find start and end positions
    int sr = null();
    int sc = null();
    int i = 0;
    repeat n {
        tuple row = maze.at(i);
        int j = 0;
        repeat m {
            int item = row.at(j);
            if item == "S"u {
                sr = i;
                sc = j;
            }
            if item == "E"u {
                er = i;
                ec = j;
            }
            j += 1;
        }
        i += 1;
    }

    init_visited(n, m);
    result_breaks = 0;
    result_prob = 0;
    result_dist = 0;
    queue = empty_tuple();
    squeue = empty_tuple();
    xqueue = empty_tuple();
    queue~enqueue([sr, sc, 0, 0, 0, maze]);
    append?(sr, sc, 0, 0, 0);

    int done? = false;
    do {
        if queue.tlen() {
            [ sr, sc, int breaks, int prob, int dist, maze ] = queue~dequeue();
            dist += 1;

            if is_solved?(sr, sc) {
                choose_best(breaks, prob, dist, maze);
                queue = empty_tuple();
            } else {
                ;; append neighbors

                int tr = sr - 1;
                int tc = sc - 1;
                if (tr >= 0) & (tc >= 0) {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; TL
                }

                tc = sc + 1;
                if (tr >= 0) & (tc < m) {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; TR
                }

                tr = sr + 1;
                if (tr < n) & (tc < m) {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; BR
                }

                tc = sc - 1;
                if (tr < n) & (tc >= 0) {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; BL
                }

                tc = sc;
                if tr < n {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; B
                }

                tr = sr - 1;
                if tr >= 0 {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; T
                }

                tr = sr;
                tc = sc - 1;
                if tc >= 0 {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; L
                }

                tc = sc + 1;
                if tc < m {
                    add_to_queue(tr, tc, breaks, prob, dist, maze); ;; R
                }
            }
        } elseif squeue.tlen() {
            [ int tsr, int tsc, int tb, int tp, int td, tuple tz ] = squeue~dequeue();
            if result_dist & (result_prob < tp) {
                squeue = empty_tuple();
            } else {
                queue~enqueue([ tsr, tsc, tb, tp, td, tz ]);
            }
        } elseif xqueue.tlen() {
            [ int tsr, int tsc, int tb, int tp, int td, tuple tz ] = xqueue~dequeue();
            if result_dist & (result_breaks < tb) {
                xqueue = empty_tuple();
            } else {
                queue~enqueue([ tsr, tsc, tb, tp, td, tz ]);
            }
        } else {
            done? = true;
        }
    } until done?;

    return ( result_breaks, result_prob, result_dist, result_maze );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}
